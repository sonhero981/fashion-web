{"ast":null,"code":"import { Action } from \"../../internal/Action.js\";\nimport { BlendModeQualifier } from \"../../qualifiers/blendMode/BlendModeQualifier.js\";\nimport { FlagQualifier } from \"../../qualifiers/flag/FlagQualifier.js\";\nimport { Qualifier } from \"../../internal/qualifier/Qualifier.js\";\nimport { createSourceFromModel } from \"../../internal/models/createSourceFromModel.js\";\nimport { createPositionFromModel } from \"../../internal/models/createPositionFromModel.js\";\nimport { createTimelinePositionFromModel } from \"../../internal/models/createTimelinePositionFromModel.js\";\nimport { ACTION_TYPE_TO_BLEND_MODE_MAP } from \"../../internal/internalConstants.js\";\n/**\n * @extends SDK.Action\n * @memberOf SDK\n * @description\n * A generic Layer action that can add a Video, Text or Image layer.<br>\n * This class can represent an overlay or an underlay.\n */\n\nclass LayerAction extends Action {\n  /**\n   * @description Creates a LayerAction to be used with overlays and underlays\n   * @param {ImageSource | TextSource | VideoSource} layerSource The Source used for the layer, use the builders provided {@link Qualifiers.Source|here}\n   */\n  constructor(layerSource) {\n    super();\n    this.source = layerSource;\n    this._actionModel = {\n      actionType: 'overlay',\n      source: layerSource.toJson()\n    };\n  }\n  /**\n   * @description Sets the layerType to 'u' (underlay) or 'l' (overlay).\n   * @param {'u' | 'l'} type\n   * @return {this}\n   */\n\n\n  setLayerType(type) {\n    this.layerType = type;\n    this._actionModel.actionType = type === 'u' ? 'underlay' : 'overlay';\n    return this;\n  }\n  /**\n   * @description Sets the timeline position of the video layer\n   * @param {Qualifiers.TimelinePosition} timelinePosition\n   * @return {this}\n   */\n\n\n  timeline(timelinePosition) {\n    this._timelinePosition = timelinePosition;\n    this._actionModel.timelinePosition = timelinePosition.toJson();\n    return this;\n  }\n  /**\n   * @description Sets the position of the layer\n   * @param {Qualifiers.Position} position\n   * @return {this}\n   */\n\n\n  position(position) {\n    this._position = position;\n    this._actionModel.position = position.toJson();\n    return this;\n  }\n  /**\n   * @description Specifies how to blend the image overlay with the base overlay\n   * @param {Qualifiers.BlendMode|BlendModeType} blendMode\n   * @return {this}\n   */\n\n\n  blendMode(blendMode) {\n    this._blendMode = blendMode;\n    const [mode, level] = `${blendMode}`.replace('e_', '').split(\":\");\n\n    if (mode === 'anti_removal') {\n      this._actionModel.blendMode = level ? {\n        blendModeType: 'antiRemoval',\n        level: level\n      } : {\n        blendModeType: 'antiRemoval'\n      };\n    } else {\n      this._actionModel.blendMode = {\n        blendModeType: mode\n      };\n    }\n\n    return this;\n  }\n  /**\n   * @private\n   * @description\n   * Closes a layer (layers are built in three stages -> /Open/Transform/Close).\n   * @return {SDK.Action}\n   */\n\n\n  closeLayer() {\n    var _a, _b, _c, _d;\n\n    const bit = new Action().addFlag(new FlagQualifier('layer_apply'));\n    (_a = this._position) === null || _a === void 0 ? void 0 : _a.qualifiers.forEach(qualifier => {\n      bit.addQualifier(qualifier);\n    }); // Flags are stored separately from qualifiers, we need to add those as well\n\n    (_b = this._position) === null || _b === void 0 ? void 0 : _b.flags.forEach(flag => {\n      bit.addFlag(flag);\n    });\n\n    if (typeof this._blendMode === \"string\") {\n      bit.addQualifier(new Qualifier('e', this._blendMode));\n    } else {\n      (_c = this._blendMode) === null || _c === void 0 ? void 0 : _c.qualifiers.forEach(qualifier => {\n        bit.addQualifier(qualifier);\n      });\n    }\n\n    (_d = this._timelinePosition) === null || _d === void 0 ? void 0 : _d.qualifiers.forEach(qualifier => {\n      bit.addQualifier(qualifier);\n    });\n    return bit;\n  }\n  /**\n   * @private\n   * @description\n   * Opens a layer (layers are built in three stages -> /Open/Transform/Close).\n   * @return string\n   */\n\n\n  openLayer() {\n    return `${this.source.getOpenSourceString(this.layerType)}`;\n  }\n  /**\n   * @description\n   * Serializes the Layer to a string\n   * @return {string}\n   */\n\n\n  toString() {\n    return [this.openLayer(), this.source.getTransformation() && this.source.getTransformation().toString(), this.closeLayer()].filter(a => a).join('/');\n  }\n\n  static fromJson(actionModel, transformationFromJson) {\n    const {\n      source,\n      actionType,\n      position,\n      timelinePosition,\n      blendMode\n    } = actionModel;\n    const sourceInstance = createSourceFromModel(source, transformationFromJson); // We are using this() to allow inheriting classes to use super.fromJson.apply(this, [actionModel])\n    // This allows the inheriting classes to determine the class to be created\n\n    const result = new this(sourceInstance);\n    const layerType = actionType === 'overlay' ? 'l' : 'u';\n    result.setLayerType(layerType);\n\n    if (position) {\n      result.position(createPositionFromModel(position));\n    }\n\n    if (timelinePosition) {\n      result.timeline(createTimelinePositionFromModel(timelinePosition));\n    }\n\n    if (blendMode) {\n      const blendModeType = ACTION_TYPE_TO_BLEND_MODE_MAP[blendMode.blendModeType] || blendMode.blendModeType;\n\n      if (blendMode === null || blendMode === void 0 ? void 0 : blendMode.level) {\n        result.blendMode(new BlendModeQualifier(blendModeType, blendMode.level));\n      } else {\n        result.blendMode(new BlendModeQualifier(blendModeType));\n      }\n    }\n\n    return result;\n  }\n\n}\n\nexport { LayerAction };","map":{"version":3,"sources":["C:/Users/sonhe/OneDrive/Desktop/New folder/nhom6-csdlnc/client/node_modules/@cloudinary/url-gen/actions/layer/LayerAction.js"],"names":["Action","BlendModeQualifier","FlagQualifier","Qualifier","createSourceFromModel","createPositionFromModel","createTimelinePositionFromModel","ACTION_TYPE_TO_BLEND_MODE_MAP","LayerAction","constructor","layerSource","source","_actionModel","actionType","toJson","setLayerType","type","layerType","timeline","timelinePosition","_timelinePosition","position","_position","blendMode","_blendMode","mode","level","replace","split","blendModeType","closeLayer","_a","_b","_c","_d","bit","addFlag","qualifiers","forEach","qualifier","addQualifier","flags","flag","openLayer","getOpenSourceString","toString","getTransformation","filter","a","join","fromJson","actionModel","transformationFromJson","sourceInstance","result"],"mappings":"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","sourcesContent":["import { Action } from \"../../internal/Action.js\";\nimport { BlendModeQualifier } from \"../../qualifiers/blendMode/BlendModeQualifier.js\";\nimport { FlagQualifier } from \"../../qualifiers/flag/FlagQualifier.js\";\nimport { Qualifier } from \"../../internal/qualifier/Qualifier.js\";\nimport { createSourceFromModel } from \"../../internal/models/createSourceFromModel.js\";\nimport { createPositionFromModel } from \"../../internal/models/createPositionFromModel.js\";\nimport { createTimelinePositionFromModel } from \"../../internal/models/createTimelinePositionFromModel.js\";\nimport { ACTION_TYPE_TO_BLEND_MODE_MAP } from \"../../internal/internalConstants.js\";\n/**\n * @extends SDK.Action\n * @memberOf SDK\n * @description\n * A generic Layer action that can add a Video, Text or Image layer.<br>\n * This class can represent an overlay or an underlay.\n */\nclass LayerAction extends Action {\n    /**\n     * @description Creates a LayerAction to be used with overlays and underlays\n     * @param {ImageSource | TextSource | VideoSource} layerSource The Source used for the layer, use the builders provided {@link Qualifiers.Source|here}\n     */\n    constructor(layerSource) {\n        super();\n        this.source = layerSource;\n        this._actionModel = {\n            actionType: 'overlay',\n            source: layerSource.toJson()\n        };\n    }\n    /**\n     * @description Sets the layerType to 'u' (underlay) or 'l' (overlay).\n     * @param {'u' | 'l'} type\n     * @return {this}\n     */\n    setLayerType(type) {\n        this.layerType = type;\n        this._actionModel.actionType = type === 'u' ? 'underlay' : 'overlay';\n        return this;\n    }\n    /**\n     * @description Sets the timeline position of the video layer\n     * @param {Qualifiers.TimelinePosition} timelinePosition\n     * @return {this}\n     */\n    timeline(timelinePosition) {\n        this._timelinePosition = timelinePosition;\n        this._actionModel.timelinePosition = timelinePosition.toJson();\n        return this;\n    }\n    /**\n     * @description Sets the position of the layer\n     * @param {Qualifiers.Position} position\n     * @return {this}\n     */\n    position(position) {\n        this._position = position;\n        this._actionModel.position = position.toJson();\n        return this;\n    }\n    /**\n     * @description Specifies how to blend the image overlay with the base overlay\n     * @param {Qualifiers.BlendMode|BlendModeType} blendMode\n     * @return {this}\n     */\n    blendMode(blendMode) {\n        this._blendMode = blendMode;\n        const [mode, level] = `${blendMode}`.replace('e_', '').split(\":\");\n        if (mode === 'anti_removal') {\n            this._actionModel.blendMode = level ? { blendModeType: 'antiRemoval', level: level } : { blendModeType: 'antiRemoval' };\n        }\n        else {\n            this._actionModel.blendMode = { blendModeType: mode };\n        }\n        return this;\n    }\n    /**\n     * @private\n     * @description\n     * Closes a layer (layers are built in three stages -> /Open/Transform/Close).\n     * @return {SDK.Action}\n     */\n    closeLayer() {\n        var _a, _b, _c, _d;\n        const bit = new Action().addFlag(new FlagQualifier('layer_apply'));\n        (_a = this._position) === null || _a === void 0 ? void 0 : _a.qualifiers.forEach((qualifier) => {\n            bit.addQualifier(qualifier);\n        });\n        // Flags are stored separately from qualifiers, we need to add those as well\n        (_b = this._position) === null || _b === void 0 ? void 0 : _b.flags.forEach((flag) => {\n            bit.addFlag(flag);\n        });\n        if (typeof this._blendMode === \"string\") {\n            bit.addQualifier(new Qualifier('e', this._blendMode));\n        }\n        else {\n            (_c = this._blendMode) === null || _c === void 0 ? void 0 : _c.qualifiers.forEach((qualifier) => {\n                bit.addQualifier(qualifier);\n            });\n        }\n        (_d = this._timelinePosition) === null || _d === void 0 ? void 0 : _d.qualifiers.forEach((qualifier) => {\n            bit.addQualifier(qualifier);\n        });\n        return bit;\n    }\n    /**\n     * @private\n     * @description\n     * Opens a layer (layers are built in three stages -> /Open/Transform/Close).\n     * @return string\n     */\n    openLayer() {\n        return `${this.source.getOpenSourceString(this.layerType)}`;\n    }\n    /**\n     * @description\n     * Serializes the Layer to a string\n     * @return {string}\n     */\n    toString() {\n        return [\n            this.openLayer(),\n            this.source.getTransformation() && this.source.getTransformation().toString(),\n            this.closeLayer()\n        ].filter((a) => a).join('/');\n    }\n    static fromJson(actionModel, transformationFromJson) {\n        const { source, actionType, position, timelinePosition, blendMode } = actionModel;\n        const sourceInstance = createSourceFromModel(source, transformationFromJson);\n        // We are using this() to allow inheriting classes to use super.fromJson.apply(this, [actionModel])\n        // This allows the inheriting classes to determine the class to be created\n        const result = new this(sourceInstance);\n        const layerType = actionType === 'overlay' ? 'l' : 'u';\n        result.setLayerType(layerType);\n        if (position) {\n            result.position(createPositionFromModel(position));\n        }\n        if (timelinePosition) {\n            result.timeline(createTimelinePositionFromModel(timelinePosition));\n        }\n        if (blendMode) {\n            const blendModeType = ACTION_TYPE_TO_BLEND_MODE_MAP[blendMode.blendModeType] || blendMode.blendModeType;\n            if (blendMode === null || blendMode === void 0 ? void 0 : blendMode.level) {\n                result.blendMode(new BlendModeQualifier(blendModeType, blendMode.level));\n            }\n            else {\n                result.blendMode(new BlendModeQualifier(blendModeType));\n            }\n        }\n        return result;\n    }\n}\nexport { LayerAction };\n"]},"metadata":{},"sourceType":"module"}