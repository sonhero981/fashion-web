{"ast":null,"code":"/**\n * Parse layer options\n * @private\n * @param {object|*} layer The layer to parse.\n * @return {string} layer transformation string\n */\nimport { isObject } from \"../utils/isObject.js\";\nimport { base64Encode } from \"../../internal/utils/base64Encode.js\";\nimport { LAYER_KEYWORD_PARAMS } from \"../consts.js\";\nimport { smartEscape } from \"../utils/smartEscape.js\";\nimport TextLayer from \"../legacyLayer/textlayer.js\";\nimport Layer from \"../legacyLayer/layer.js\";\nexport function textStyle(layer) {\n  const keywords = [];\n  let style = \"\";\n  Object.keys(LAYER_KEYWORD_PARAMS).forEach(attr => {\n    let default_value = LAYER_KEYWORD_PARAMS[attr];\n    let attr_value = layer[attr] || default_value;\n\n    if (attr_value !== default_value) {\n      keywords.push(attr_value);\n    }\n  });\n  Object.keys(layer).forEach(attr => {\n    if (attr === \"letter_spacing\" || attr === \"line_spacing\") {\n      keywords.push(`${attr}_${layer[attr]}`);\n    }\n\n    if (attr === \"font_hinting\") {\n      keywords.push(`${attr.split(\"_\").pop()}_${layer[attr]}`);\n    }\n\n    if (attr === \"font_antialiasing\") {\n      keywords.push(`antialias_${layer[attr]}`);\n    }\n  });\n\n  if (layer.hasOwnProperty(\"font_size\" || \"font_family\") || !keywords || keywords.length === 0) {\n    if (!layer.font_size) throw `Must supply font_size for text in overlay/underlay`;\n    if (!layer.font_family) throw `Must supply font_family for text in overlay/underlay`;\n    keywords.unshift(layer.font_size);\n    keywords.unshift(layer.font_family);\n    style = keywords.filter(a => a).join(\"_\");\n  }\n\n  return style;\n}\nexport function processLayer(layer) {\n  if (layer instanceof TextLayer || layer instanceof Layer) {\n    return layer.toString();\n  }\n\n  let result = '';\n\n  if (isObject(layer)) {\n    if (layer.resource_type === \"fetch\" || layer.url != null) {\n      result = `fetch:${base64Encode(layer.url)}`;\n    } else {\n      let public_id = layer.public_id;\n      let format = layer.format;\n      let resource_type = layer.resource_type || \"image\";\n      let type = layer.type || \"upload\";\n      let text = layer.text;\n      let style = null;\n      let components = [];\n      const noPublicId = !public_id || public_id.length === 0;\n\n      if (!noPublicId) {\n        public_id = public_id.replace(new RegExp(\"/\", 'g'), \":\");\n\n        if (format != null) {\n          public_id = `${public_id}.${format}`;\n        }\n      }\n\n      if ((!text || text.length === 0) && resource_type !== \"text\") {\n        if (noPublicId) {\n          throw \"Must supply public_id for resource_type layer_parameter\";\n        }\n\n        if (resource_type === \"subtitles\") {\n          style = textStyle(layer);\n        }\n      } else {\n        resource_type = \"text\";\n        type = null; // type is ignored for text layers\n\n        style = textStyle(layer);\n\n        if (text && text.length >= 0) {\n          const noStyle = !style;\n\n          if (!(noPublicId || noStyle) || noPublicId && noStyle) {\n            throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay\";\n          }\n\n          let re = /\\$\\([a-zA-Z]\\w*\\)/g;\n          let start = 0;\n          let textSource = smartEscape(decodeURIComponent(text), /[,\\/]/g);\n          text = \"\";\n\n          for (let res = re.exec(textSource); res; res = re.exec(textSource)) {\n            text += smartEscape(textSource.slice(start, res.index));\n            text += res[0];\n            start = res.index + res[0].length;\n          }\n\n          text += encodeURIComponent(textSource.slice(start));\n        }\n      }\n\n      if (resource_type !== \"image\") {\n        components.push(resource_type);\n      }\n\n      if (type !== \"upload\") {\n        components.push(type);\n      }\n\n      components.push(style);\n      components.push(public_id);\n      components.push(text);\n      result = components.filter(a => a).join(\":\");\n    }\n  } else if (/^fetch:.+/.test(layer)) {\n    result = `fetch:${base64Encode(layer.substr(6))}`;\n  } else {\n    result = layer;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["C:/Users/sonhe/OneDrive/Desktop/New folder/nhom6-csdlnc/client/node_modules/@cloudinary/url-gen/backwards/transformationProcessing/processLayer.js"],"names":["isObject","base64Encode","LAYER_KEYWORD_PARAMS","smartEscape","TextLayer","Layer","textStyle","layer","keywords","style","Object","keys","forEach","attr","default_value","attr_value","push","split","pop","hasOwnProperty","length","font_size","font_family","unshift","filter","a","join","processLayer","toString","result","resource_type","url","public_id","format","type","text","components","noPublicId","replace","RegExp","noStyle","re","start","textSource","decodeURIComponent","res","exec","slice","index","encodeURIComponent","test","substr"],"mappings":"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","sourcesContent":["/**\n * Parse layer options\n * @private\n * @param {object|*} layer The layer to parse.\n * @return {string} layer transformation string\n */\nimport { isObject } from \"../utils/isObject.js\";\nimport { base64Encode } from \"../../internal/utils/base64Encode.js\";\nimport { LAYER_KEYWORD_PARAMS } from \"../consts.js\";\nimport { smartEscape } from \"../utils/smartEscape.js\";\nimport TextLayer from \"../legacyLayer/textlayer.js\";\nimport Layer from \"../legacyLayer/layer.js\";\nexport function textStyle(layer) {\n    const keywords = [];\n    let style = \"\";\n    Object.keys(LAYER_KEYWORD_PARAMS).forEach((attr) => {\n        let default_value = LAYER_KEYWORD_PARAMS[attr];\n        let attr_value = layer[attr] || default_value;\n        if (attr_value !== default_value) {\n            keywords.push(attr_value);\n        }\n    });\n    Object.keys(layer).forEach((attr) => {\n        if (attr === \"letter_spacing\" || attr === \"line_spacing\") {\n            keywords.push(`${attr}_${layer[attr]}`);\n        }\n        if (attr === \"font_hinting\") {\n            keywords.push(`${attr.split(\"_\").pop()}_${layer[attr]}`);\n        }\n        if (attr === \"font_antialiasing\") {\n            keywords.push(`antialias_${layer[attr]}`);\n        }\n    });\n    if (layer.hasOwnProperty(\"font_size\" || \"font_family\") || !keywords || keywords.length === 0) {\n        if (!layer.font_size)\n            throw `Must supply font_size for text in overlay/underlay`;\n        if (!layer.font_family)\n            throw `Must supply font_family for text in overlay/underlay`;\n        keywords.unshift(layer.font_size);\n        keywords.unshift(layer.font_family);\n        style = keywords.filter((a) => a).join(\"_\");\n    }\n    return style;\n}\nexport function processLayer(layer) {\n    if (layer instanceof TextLayer || layer instanceof Layer) {\n        return layer.toString();\n    }\n    let result = '';\n    if (isObject(layer)) {\n        if (layer.resource_type === \"fetch\" || (layer.url != null)) {\n            result = `fetch:${base64Encode(layer.url)}`;\n        }\n        else {\n            let public_id = layer.public_id;\n            let format = layer.format;\n            let resource_type = layer.resource_type || \"image\";\n            let type = layer.type || \"upload\";\n            let text = layer.text;\n            let style = null;\n            let components = [];\n            const noPublicId = !public_id || public_id.length === 0;\n            if (!noPublicId) {\n                public_id = public_id.replace(new RegExp(\"/\", 'g'), \":\");\n                if (format != null) {\n                    public_id = `${public_id}.${format}`;\n                }\n            }\n            if ((!text || text.length === 0) && resource_type !== \"text\") {\n                if (noPublicId) {\n                    throw \"Must supply public_id for resource_type layer_parameter\";\n                }\n                if (resource_type === \"subtitles\") {\n                    style = textStyle(layer);\n                }\n            }\n            else {\n                resource_type = \"text\";\n                type = null;\n                // type is ignored for text layers\n                style = textStyle(layer);\n                if (text && text.length >= 0) {\n                    const noStyle = !style;\n                    if (!(noPublicId || noStyle) || (noPublicId && noStyle)) {\n                        throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay\";\n                    }\n                    let re = /\\$\\([a-zA-Z]\\w*\\)/g;\n                    let start = 0;\n                    let textSource = smartEscape(decodeURIComponent(text), /[,\\/]/g);\n                    text = \"\";\n                    for (let res = re.exec(textSource); res; res = re.exec(textSource)) {\n                        text += smartEscape(textSource.slice(start, res.index));\n                        text += res[0];\n                        start = res.index + res[0].length;\n                    }\n                    text += encodeURIComponent(textSource.slice(start));\n                }\n            }\n            if (resource_type !== \"image\") {\n                components.push(resource_type);\n            }\n            if (type !== \"upload\") {\n                components.push(type);\n            }\n            components.push(style);\n            components.push(public_id);\n            components.push(text);\n            result = components.filter((a) => a).join(\":\");\n        }\n    }\n    else if (/^fetch:.+/.test(layer)) {\n        result = `fetch:${base64Encode(layer.substr(6))}`;\n    }\n    else {\n        result = layer;\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}