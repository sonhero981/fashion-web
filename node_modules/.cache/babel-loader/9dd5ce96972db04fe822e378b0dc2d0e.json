{"ast":null,"code":"import { CONDITIONAL_OPERATORS, RESERVED_NAMES } from \"../internal/internalConstants.js\";\nimport { ExpressionQualifier } from \"./expression/ExpressionQualifier.js\";\n/**\n * @description\n * Used for variable or conditional expressions\n * <b>Learn more:</b> {@link https://cloudinary.com/documentation/user_defined_variables#arithmetic_expressions|Arithmetic expressions }\n * @namespace Expression\n * @memberOf Qualifiers\n */\n\n/**\n * @summary qualifier\n * @memberOf Qualifiers.Expression\n * @return {Qualifiers.Expression.ExpressionQualifier}\n */\n\nfunction expression(exp) {\n  // Prepare the CONDITIONAL_OPERATORS object to be used in a regex\n  // Properly escape |, +, ^ and *\n  // This step also adds a regex space ( \\s ) around each operator, since these are only replaced when wrapped with spaces\n  // $foo * $bar is replaced to $foo_mul_$bar\n  // $foo*bar is treated AS-IS.\n  const reservedOperatorList = Object.keys(CONDITIONAL_OPERATORS).map(key => {\n    return `\\\\s${key.replace(/(\\*|\\+|\\^|\\|)/g, '\\\\$1')}\\\\s`;\n  }); // reservedOperatorList is now an array of values, joining with | creates the regex list\n\n  const regexSafeOperatorList = reservedOperatorList.join('|');\n  const operatorsReplaceRE = new RegExp(`(${regexSafeOperatorList})`, \"g\"); // First, we replace all the operators\n  // Notice how we pad the matched operators with `_`, this is following the step above.\n  // This turns $foo * $bar into $foo_mul_$bar (notice how the spaces were replaced with an underscore\n\n  const stringWithOperators = exp.toString().replace(operatorsReplaceRE, match => {\n    // match contains spaces around the expression, we need to trim it as the original list\n    // does not contain spaces.\n    return `_${CONDITIONAL_OPERATORS[match.trim()]}_`;\n  }); // Handle reserved names (width, height, etc.)\n\n  const ReservedNames = Object.keys(RESERVED_NAMES);\n  const regexSafeReservedNameList = ReservedNames.join('|'); // Gather all statements that begin with a dollar sign, underscore or a space\n  // Gather all RESERVED NAMES\n  // $foo_bar is matched\n  // height is matched\n\n  const reservedNamesRE = new RegExp(`(\\\\$_*[^_ ]+)|${regexSafeReservedNameList}`, \"g\"); // Since this regex captures both user variables and our reserved keywords, we need to add some logic in the replacer\n\n  const stringWithVariables = stringWithOperators.replace(reservedNamesRE, match => {\n    // Do not do anything to user variables (anything starting with $)\n    if (match.startsWith('$')) {\n      return match;\n    } else {\n      return RESERVED_NAMES[match] || match;\n    }\n  }); // Serialize remaining spaces with an underscore\n\n  const finalExpressionString = stringWithVariables.replace(/\\s/g, '_');\n  return new ExpressionQualifier(finalExpressionString);\n} // as a namespace\n\n\nconst Expression = {\n  expression\n};\nexport { Expression, expression };","map":{"version":3,"sources":["C:/Users/sonhe/OneDrive/Desktop/New folder/nhom6-csdlnc/client/node_modules/@cloudinary/url-gen/qualifiers/expression.js"],"names":["CONDITIONAL_OPERATORS","RESERVED_NAMES","ExpressionQualifier","expression","exp","reservedOperatorList","Object","keys","map","key","replace","regexSafeOperatorList","join","operatorsReplaceRE","RegExp","stringWithOperators","toString","match","trim","ReservedNames","regexSafeReservedNameList","reservedNamesRE","stringWithVariables","startsWith","finalExpressionString","Expression"],"mappings":"AAAA,SAASA,qBAAT,EAAgCC,cAAhC,QAAsD,kCAAtD;AACA,SAASC,mBAAT,QAAoC,qCAApC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,UAAT,CAAoBC,GAApB,EAAyB;AACrB;AACA;AACA;AACA;AACA;AACA,QAAMC,oBAAoB,GAAGC,MAAM,CAACC,IAAP,CAAYP,qBAAZ,EAAmCQ,GAAnC,CAAwCC,GAAD,IAAS;AACzE,WAAQ,MAAKA,GAAG,CAACC,OAAJ,CAAY,gBAAZ,EAA8B,MAA9B,CAAsC,KAAnD;AACH,GAF4B,CAA7B,CANqB,CASrB;;AACA,QAAMC,qBAAqB,GAAGN,oBAAoB,CAACO,IAArB,CAA0B,GAA1B,CAA9B;AACA,QAAMC,kBAAkB,GAAG,IAAIC,MAAJ,CAAY,IAAGH,qBAAsB,GAArC,EAAyC,GAAzC,CAA3B,CAXqB,CAYrB;AACA;AACA;;AACA,QAAMI,mBAAmB,GAAGX,GAAG,CAACY,QAAJ,GACvBN,OADuB,CACfG,kBADe,EACMI,KAAD,IAAW;AACxC;AACA;AACA,WAAQ,IAAGjB,qBAAqB,CAACiB,KAAK,CAACC,IAAN,EAAD,CAAe,GAA/C;AACH,GAL2B,CAA5B,CAfqB,CAqBrB;;AACA,QAAMC,aAAa,GAAGb,MAAM,CAACC,IAAP,CAAYN,cAAZ,CAAtB;AACA,QAAMmB,yBAAyB,GAAGD,aAAa,CAACP,IAAd,CAAmB,GAAnB,CAAlC,CAvBqB,CAwBrB;AACA;AACA;AACA;;AACA,QAAMS,eAAe,GAAG,IAAIP,MAAJ,CAAY,iBAAgBM,yBAA0B,EAAtD,EAAyD,GAAzD,CAAxB,CA5BqB,CA6BrB;;AACA,QAAME,mBAAmB,GAAGP,mBAAmB,CAACL,OAApB,CAA4BW,eAA5B,EAA8CJ,KAAD,IAAW;AAChF;AACA,QAAIA,KAAK,CAACM,UAAN,CAAiB,GAAjB,CAAJ,EAA2B;AACvB,aAAON,KAAP;AACH,KAFD,MAGK;AACD,aAAOhB,cAAc,CAACgB,KAAD,CAAd,IAAyBA,KAAhC;AACH;AACJ,GAR2B,CAA5B,CA9BqB,CAuCrB;;AACA,QAAMO,qBAAqB,GAAGF,mBAAmB,CAACZ,OAApB,CAA4B,KAA5B,EAAmC,GAAnC,CAA9B;AACA,SAAO,IAAIR,mBAAJ,CAAwBsB,qBAAxB,CAAP;AACH,C,CACD;;;AACA,MAAMC,UAAU,GAAG;AACftB,EAAAA;AADe,CAAnB;AAGA,SAASsB,UAAT,EAAqBtB,UAArB","sourcesContent":["import { CONDITIONAL_OPERATORS, RESERVED_NAMES } from \"../internal/internalConstants.js\";\nimport { ExpressionQualifier } from \"./expression/ExpressionQualifier.js\";\n/**\n * @description\n * Used for variable or conditional expressions\n * <b>Learn more:</b> {@link https://cloudinary.com/documentation/user_defined_variables#arithmetic_expressions|Arithmetic expressions }\n * @namespace Expression\n * @memberOf Qualifiers\n */\n/**\n * @summary qualifier\n * @memberOf Qualifiers.Expression\n * @return {Qualifiers.Expression.ExpressionQualifier}\n */\nfunction expression(exp) {\n    // Prepare the CONDITIONAL_OPERATORS object to be used in a regex\n    // Properly escape |, +, ^ and *\n    // This step also adds a regex space ( \\s ) around each operator, since these are only replaced when wrapped with spaces\n    // $foo * $bar is replaced to $foo_mul_$bar\n    // $foo*bar is treated AS-IS.\n    const reservedOperatorList = Object.keys(CONDITIONAL_OPERATORS).map((key) => {\n        return `\\\\s${key.replace(/(\\*|\\+|\\^|\\|)/g, '\\\\$1')}\\\\s`;\n    });\n    // reservedOperatorList is now an array of values, joining with | creates the regex list\n    const regexSafeOperatorList = reservedOperatorList.join('|');\n    const operatorsReplaceRE = new RegExp(`(${regexSafeOperatorList})`, \"g\");\n    // First, we replace all the operators\n    // Notice how we pad the matched operators with `_`, this is following the step above.\n    // This turns $foo * $bar into $foo_mul_$bar (notice how the spaces were replaced with an underscore\n    const stringWithOperators = exp.toString()\n        .replace(operatorsReplaceRE, (match) => {\n        // match contains spaces around the expression, we need to trim it as the original list\n        // does not contain spaces.\n        return `_${CONDITIONAL_OPERATORS[match.trim()]}_`;\n    });\n    // Handle reserved names (width, height, etc.)\n    const ReservedNames = Object.keys(RESERVED_NAMES);\n    const regexSafeReservedNameList = ReservedNames.join('|');\n    // Gather all statements that begin with a dollar sign, underscore or a space\n    // Gather all RESERVED NAMES\n    // $foo_bar is matched\n    // height is matched\n    const reservedNamesRE = new RegExp(`(\\\\$_*[^_ ]+)|${regexSafeReservedNameList}`, \"g\");\n    // Since this regex captures both user variables and our reserved keywords, we need to add some logic in the replacer\n    const stringWithVariables = stringWithOperators.replace(reservedNamesRE, (match) => {\n        // Do not do anything to user variables (anything starting with $)\n        if (match.startsWith('$')) {\n            return match;\n        }\n        else {\n            return RESERVED_NAMES[match] || match;\n        }\n    });\n    // Serialize remaining spaces with an underscore\n    const finalExpressionString = stringWithVariables.replace(/\\s/g, '_');\n    return new ExpressionQualifier(finalExpressionString);\n}\n// as a namespace\nconst Expression = {\n    expression\n};\nexport { Expression, expression };\n"]},"metadata":{},"sourceType":"module"}